Here is some of the data that should be stored for each operation (mnemonic variation):
    - Opcode map #1 (or "implied leading opcode bytes"):
        A 5-bit number that goes into VEX.mmmmm. Detected through the opcode (required for VEX prefix).
        1 = 0F
        2 = 0F38
        3 = 0F3A
    - Opcode map #2 (or "implied prefixes"):
        A 2-bit number that goes into VEX.pp. Detected through the operation prefix (defaults to 0).
        0 = none
        1 = 66
        2 = F3
        3 = F2


Some examples of VEX-encoded instructions (with outliers):
    - (v)addpd: normal VEX instruction.
        Without a "v" at the start, it has 2 operands and is encoded without a VEX prefix.
        With "v" at the start, it has 3 operands and is encoded with a VEX prefix.

    - andn: VEX instruction that can't be written with a "v" at the start,
        but is always encoded with a VEX prefix. Has 3 operands (all GPRs). Encoding: 0F38F2
        * Another example of pretty much the same thing: "pext" instruction. Encoding: F3)0F38F5
        * There might be a pattern here. Can SIMD instructions with opcode Fx not be encoded without VEX?
        * Another example: bzhi instruction (again, exact same thing). 0F38F5
        * bextr: 0F38F7
        * sarx: F3)0F38F7
        * shlx: 66)0F38F7
        * shrx: F2)0F38F7
        * Note this is not a pattern for "normal" mnemonics with the letter X added.
          For example, adcx has a SIMD encoding (66)0F38F6), but no valid VEX encoding.
        * Conjecture: These are a subset of what the Intel docs call "VEX-encoded GPR instructions."
          The name is misleading, though - some of these instructions don't have a VEX encoding at all.
          For example, the lzcnt instruction is listed as such (encoding F3)0FBD), but has only 2 operands
          and cannot be encoded with a VEX prefix (it behaves more like a standard SIMD instruction).
          Same applies for the tzcnt instruction (encoding F3)0FBC, 2 operands),
          and the invpcid (encoding 66)0F3882, 2 operands).
          Besides these 3 outliers, the rest of these instructions seem to follow the pattern:
            - andn      0F38F2 r    3 operands
            - bextr     0F38F7 r    3 operands
            - blsi      0F38F3 3    2 operands
            - blsmsk    0F38F3 2    2 operands
            - blsr      0F38F3 1    2 operands
            - bzhi      0F38F5 r    3 operands
            - mulx   F2)0F38F6 r    3 operands
            - pdep   F2)0F38F5 r    3 operands
            - pext   F3)0F38F5 r    3 operands
            - rorx   F2)0F3AF0 r    3 operands (2 registers, 1 immediate)
            - sarx   F3)0F38F7 r    3 operands
            - shlx   66)0F38F7 r    3 operands
            - shrx   F2)0F38F7 r    3 operands
        * Correction: Not all SIMD instructions with opcode Fx have to have a VEX prefix.
          For example, the (v)paddb/w/d/q instructions have encoding 0FFC/FD/FE/D4 (2 operands), but can be encoded
          without a VEX prefix.
        * Interestingly, however, the instructions listed above comprise the set of all instructions that must be
          encoded with a VEX prefix but whose mnemonics don't start with the letter 'v'.
        * So, we can actually make a generalization here:

         Any instructions that utilize 3 GPR operands (or 2 GPR operands if the extension is a digit),
         MUST be encoded with a VEX prefix, regardless of whether or not their mnemonic starts with the letter 'v'.

         Note that the requirement that these be GPR operands is needed, because other AVX instructions with 3 operands
         that are vector registers can only be encoded if the 'V' prefix is specified.

    - (v)psllw: almost normal VEX instruction. Without V has 2 operands and no VEX prefix,
        with V has 3 operands and a VEX prefix. However, one of the variations with the
        VEX prefix (with V) has 2 register (XMM) operands and an immediate operand.

    - (v)ptest: another nearly normal VEX instruction. Without V has 2 operands and no VEX prefix,
        with V has (still!) 2 operands and a VEX prefix. With V allows use of YMM registers,
        but also a variation with XMM registers (same as with no V).
    
    - (v)blendvpd: without V has 2 operands, plus an implicit xmm0 operand.
        With V has 4 operands - one of them being stored in bits 7:4 of the imm8 byte following the
        instruction (bits 3:0 are ignored).




So I think what I'll do is something like this:
    Have a '>' prefix for op catchers in the mnemonic format, which specifies a VEX operand.
    This operand will always be encoded into the VVVVV field of the VEX prefix (if it is present,
    otherwise the field will default to 11111).
    However, it will only be required if the mnemonic starts with the letter 'v' (or if it is a GPR
    operand).

The instruction compiler will generate a VEX prefix only if the mnemonic compiler has returned a valid
VVVVV field.
The mnemonic compiler will return a VVVVV field if one of two conditions is met:
1) the mnemonic starts with the letter 'v'
2) the "forceVex" flag of the operation is set to true (this is decided on generation if 3 GPR operands are provided)
If one of these two conditions is met, the mnemonic compiler will also necessitate that the VEX operands (if any) be provided.