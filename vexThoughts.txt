Here is some of the data that should be stored for each operation (mnemonic variation):
    - Opcode map #1 (or "implied leading opcode bytes"):
        A 5-bit number that goes into VEX.mmmmm. Detected through the opcode (required for VEX prefix).
        1 = 0F
        2 = 0F38
        3 = 0F3A
    - Opcode map #2 (or "implied prefixes"):
        A 2-bit number that goes into VEX.pp. Detected through the operation prefix (defaults to 0).
        0 = none
        1 = 66
        2 = F3
        3 = F2


Some examples of VEX-encoded instructions (with outliers):
    - (v)addpd: normal VEX instruction.
        Without a "v" at the start, it has 2 operands and is encoded without a VEX prefix.
        With "v" at the start, it has 3 operands and is encoded with a VEX prefix.

    - andn: VEX instruction that can't be written with a "v" at the start,
        but is always encoded with a VEX prefix. Has 3 operands (all GPRs).
        * Another example of pretty much the same thing: "pext" instruction

    - (v)psllw: almost normal VEX instruction. Without V has 2 operands and no VEX prefix,
        with V has 3 operands and a VEX prefix. However, one of the variations with the
        VEX prefix (with V) has 2 register (XMM) operands and an immediate operand.

    - (v)ptest: another nearly normal VEX instruction. Without V has 2 operands and no VEX prefix,
        with V has (still!) 2 operands and a VEX prefix. With V allows use of YMM registers,
        but also a variation with XMM registers (same as with no V).
    
    - (v)blendvpd: without V has 2 operands, plus an "implicit xmm0" operand (should it be written?)
        With V has 4 operands - one of them being stored in bits 7:4 of the imm8 byte following the
        instruction (bits 3:0 are ignored).