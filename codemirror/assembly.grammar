@top Program { statement ((';' | '\n') statement)*  }

@context ctxTracker from "./asmPlugin"
@external tokens tokenizer from "./asmPlugin" {
  Register,
  Directive,
  Comment,
  Opcode, IOpcode,
  RelOpcode, IRelOpcode,
  Prefix,
  word,
  Ptr,
  Offset
}

@tokens {
  charString { "'" (![\\\n'] | "\\" _)* "'"? }
  FullString { '"' (![\\\n"] | "\\" _)* '"'? }
  number { ('0x' $[0-9a-fA-F]+) | ('0o' $[0-7]+) | ('0b' $[0-1]+) | $[0-9.]+ ('e' $[0-9]+)? }
  unary { '+' | '-' | '~' | '!' }
  operator { $[+\-/*%|&^<>!] | '||' | '&&' | '>>' | '<<' | '<>' | '==' | '!=' | '>=' | '<='}
  decorator { '{' ![}]* '}'? }
}

statement {
  LabelDefinition |
  (
  InstructionStatement |
  DirectiveStatement |
  SymbolDefinition
  ) Comment?
}


InstructionStatement {
  Prefix* VEXRound? (
    (Opcode commaSep<(Register | Immediate | Relative | Memory) VEXMask?>)
    |
    (IOpcode commaSep<Ptr? (Register | (Offset Expression) | IImmediate | IMemory) VEXMask?>)
    |
    (RelOpcode (('*' (Register | Relative | Memory)) | Register | Expression | Memory))
    |
    (IRelOpcode (Register | Expression | IMemory))
  )?
}

DirectiveStatement {
  Directive commaSep<Expression | FullString>
}

Immediate {
  '$' Expression
}

Memory {
  Relative? '(' ("" | Register ("," (Register | number)?)*) ')'
}

IMemory {
  Relative? '[' iMemExpr ']'
}

VEXRound { decorator }
VEXMask { '{' Register? '}'?}

IImmediate[@dynamicPrecedence=1] { (unary | '(')* (number | charString) ')'* (operator IImmediate)? ~immSplit }
Relative { (unary | '(')* (number | charString | word) ')'* (operator Relative)? ~immSplit }
Expression { (unary | '(')* (number | charString | word) ')'* (operator Expression)? }
iMemExpr { (unary | '(')* (Register | number | charString | word) ')'* (operator iMemExpr)? }

LabelDefinition { word ':' }
SymbolDefinition { word '=' Expression }

commaSep<content> {
  "" | content ("," content?)*
}