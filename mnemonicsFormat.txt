A mnemonic, at its core, is a method of telling the assembler how to encode a given string.

The assembler doesn't know what "mov %rax, %rsi" means - it might understand that %rax and %rsi are
registers of size 64-bits, but it doesn't know how to encode it.
The assembler has a few basic functions that are common to many mnemonics, like generating a ModRM byte,
an SIB byte, prefixes, immediates, etc.. However, each mnemonic has its own quirks and flavors,
and each mnemonic expects different operands and interprets them differently.

For essentially all instructions, in their textual form, the assembler understands them as:
    - An opcode (or mneomnic name, e.g. "mov").
    - A list of operands - these can be registers, immediates, memory etc., and each may or may not have a known size.
    * Sometimes there may be an opcode suffix (e.g. the 'l' in "movl"). These are simply there to tell the assembler
        how to interpret operands that it's not 100% sure about, like immediates and memory.

The opcode name is used to find the mnemonic list that is used to encode the instruction.
Note that a single opcode name typically refers to multiple mnemonic variations. The assembler
should go through each of them in order, attempt to enter the list of operands into it, and,
on success, stop and continue on with the encoding using the results. If none of the variations
match, the operands entered into the mnemonic were incorrect.

We can infer from this that a mnemonic has a single function: take in a list of operands,
check if they can be encoded, and if they can, return the information required to complete the encoding.
The most necessary part of this information is an updated list of operands. Some operands may have
incomplete information to encode - for example, an immediate operand's size, unless explicitly given, is
unknown to the assembler. Part of the mnemonic's job is to attempt to infer (if possible) these missing
facts from other information, whether that be the size of the other operands or some special values for
the given opcode.


Format (each line break indicates a space character):
    <opcode in hex>
    <extension> [offset from byte opcode - difference between opcode for byte size and for other size. defaults to 1]
    <operand name> [operand sizes (defaults appear first) (no sizes means use the same as the previous operand, or (for immediate implicit ops and some op types like segment registers) size doesn't matter)]
    [repeat for all operands, separated by spaces]
    [repeat for all mnemonic variations, separated by line breaks]

Example for "push" instruction:
50 o RQw        # opcode 0x50, register goes in opcode, accepts registers of size word or quadword (default to quadword without prefix)
6A z-2 Ib~wl    # opcode 0x6A, solitary opcode (offset -2 from byte), accepts signed immediate of size byte, word (only if explicit) or double-word (default to byte)
FF 6 mQw        # opcode 0xFF, extension 6, accepts memory of size word or quadword (default to quadword without prefix)
FA0 z s_4       # opcode 0x0FA0, solitary opcode, accepts segment register of id 4 (fs)
FA8 z s_5       # opcode 0x0FA8, solitary opcode, accepts segment register of id 5 (gs)

Example for "mov" instruction:
88 r Rbwlq r    # opcode 0x88, register goes in modrm, accepts a register of size byte, word, doubleword or quadword, followed by a register/memory of the same size
8A r rbwlq R    # opcode 0x8A, same as above but operands reversed
8C r s Rwlq/mW  # opcode 0x8C, register goes in modrm, accepts a segment register, followed by either A) a register of size word, doubleword or quadword, or B) memory of size word (no prefix/suffix needed)
8E r rWq s      # opcode 0x8E, register goes in modrm, accepts a register/memory of size word (no prefix, implicit for memory) or quadword, followed by a segment register
A0 z obwlq R_0  # opcode 0xA0, solitary opcode, accepts a moffset of size byte, word, doubleword or quadword, followed by an unencoded ax register of the same size
A2 z R_0bwlq o  # opcode 0xA2, same as above but operands reversed
C7 0 Il rq      # opcode 0xC7, extension 0, accepts a signed immediate of size doubleword, followed by a register/memory of size quadword (this should be placed higher than the next to ensure a shorter encoding)
B0 o8 ibwlq R   # opcode 0xB0, register goes in opcode (offset 8 from byte), accepts an unsigned immediate of size byte, word, doubleword or quadword, followed by a register of the same size
C6 0 ibwl r     # opcode 0xC6, extension 0, accepts an unsigned immediate of size byte, word or doubleword, followed by a register of the same size

Example for "add" instruction (this can be extended to all other arithmetic instructions, like adc, sub, xor, and, etc.):
4 z ibwl R_0    # opcode 0x04, solitary opcode, accepts an unsigned immediate of size byte, word or doubleword, followed by an unencoded ax register of the same size
5 z Il R_0q     # opcode 0x05, solitary opcode, accepts a signed immediate of size doubleword, followed by an unencoded ax register of size quadword
83 0 Ib rwlq
80 0 ibwl r
81 0 Il rq
0 r Rbwlq r
2 r rbwlq R

Example for "sal" instruction:
D0 4 I_1 rbwlq
D2 4 R_1b rbwlq
C0 4 Ib rbwlq

Example for "fadd" instruction:
D8 0 ml
DC 0 mQ
D8C0 o f f_0
DCC0 o f_0 f


Extensions:
    - 0-7 - opcode extension, goes to modrm
    - 'r' - register id goes to modrm
    - 'o' - register id goes to opcode (no modrm)
    - 'z' - solitary opcode (no modrm, might be followed by an immediate/offset though)

Operand names (for multiple choices, separate by '/'):
    - 'R' - register only
    - 'r' - register/memory (rm)
    - 'm' - memory only
    - 'i' - unsigned immediate
    - 'I' - signed immediate
    - 's' - segment register
    - 'f' - floating-point register (st)
    - 'M' - MMX register
    - 'x' - XMM register
    - 'o' - moffset (memory that's just a simple offset)
    Implicit types (these won't be encoded in the instruction):
    - Follow operand name with '_', then specification.
        For registers, this is the register id (e.g. ax = R_0)
        For immediates, this is the immediate value (e.g. 1 = i_1)
    - '-' - invisible operand (this is for mnemonics that have a size but no operands, e.g. string operations or pushf)

Operand sizes (capitalize if prefix isn't needed and memory ops should default to this):
    - 'b' - byte
    - 'w' - word
    - 'l' - double-word
    - 'q' - quad-word
    - '~' - before a size that must be explicitly chosen by an opcode suffix