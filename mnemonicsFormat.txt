A mnemonic, at its core, is a method of telling the assembler how to encode a given string.

The assembler doesn't know what "mov %rax, %rsi" means - it might understand that %rax and %rsi are
registers of size 64-bits, but it doesn't know how to encode it.
The assembler has a few basic functions that are common to many mnemonics, like generating a ModRM byte,
an SIB byte, prefixes, immediates, etc.. However, each mnemonic has its own quirks and flavors,
and each mnemonic expects different operands and interprets them differently.

For essentially all instructions, in their textual form, the assembler understands them as:
    - An opcode (or mneomnic name, e.g. "mov").
    - A list of operands - these can be registers, immediates, memory etc., and each may or may not have a known size.
    * Sometimes there may be an opcode suffix (e.g. the 'l' in "movl"). These are simply there to tell the assembler
        how to interpret operands that it's not 100% sure about, like immediates and memory.

The opcode name is used to find the mnemonic list that is used to encode the instruction.
Note that a single opcode name typically refers to multiple mnemonic variations. The assembler
should go through each of them in order, attempt to enter the list of operands into it, and,
on success, stop and continue on with the encoding using the results. If none of the variations
match, the operands entered into the mnemonic were incorrect.

We can infer from this that a mnemonic has a single function: take in a list of operands,
check if they can be encoded, and if they can, return the information required to complete the encoding.
The most necessary part of this information is an updated list of operands. Some operands may have
incomplete information to encode - for example, an immediate operand's size, unless explicitly given, is
unknown to the assembler. Part of the mnemonic's job is to attempt to infer (if possible) these missing
facts from other information, whether that be the size of the other operands or some special values for
the given opcode.


Format (each line break indicates a space character):
    [optional prefix followed by a bracket, which will be added before REX] <opcode in hex>
    <extension> [offset from byte opcode - difference between opcode for byte size and for other size. defaults to 1]
    <operand name> [operand sizes (should be in ascending order) (no sizes means use the same as the previous operand, or (for immediate implicit ops and some op types like segment registers) size doesn't matter)]
    [repeat for all operands, separated by spaces]
    [repeat for all mnemonic variations, separated by line breaks]

Example for "push" instruction:
50 o RwQ        # opcode 0x50, register goes in opcode, accepts registers of size word or quadword (default to quadword without prefix)
6A z-2 Ib~wl    # opcode 0x6A, solitary opcode (offset -2 from byte), accepts signed immediate of size byte, word (only if explicit) or double-word (default to byte)
FF 6 mwQ        # opcode 0xFF, extension 6, accepts memory of size word or quadword (default to quadword without prefix)
0FA0 z s_4      # opcode 0x0FA0, solitary opcode, accepts segment register of id 4 (fs)
0FA8 z s_5      # opcode 0x0FA8, solitary opcode, accepts segment register of id 5 (gs)

Example for "mov" instruction:
88 r Rbwlq r    # opcode 0x88, register goes in modrm, accepts a register of size byte, word, doubleword or quadword, followed by a register/memory of the same size
8A r rbwlq R    # opcode 0x8A, same as above but operands reversed
8C r s rWlq     # opcode 0x8C, register goes in modrm, accepts a segment register, followed by a register/memory of size word, doubleword or quadword (defaults to word with no prefix)
8E r rWq s      # opcode 0x8E, register goes in modrm, accepts a register/memory of size word (no prefix, implicit for memory) or quadword, followed by a segment register
A0 z obwlq R_0  # opcode 0xA0, solitary opcode, accepts a moffset of size byte, word, doubleword or quadword, followed by an unencoded ax register of the same size
A2 z R_0bwlq o  # opcode 0xA2, same as above but operands reversed
C7 0 Il rq      # opcode 0xC7, extension 0, accepts a signed immediate of size doubleword, followed by a register/memory of size quadword (this should be placed higher than the next to ensure a shorter encoding)
B0 o8 ibwlq R   # opcode 0xB0, register goes in opcode (offset 8 from byte), accepts an unsigned immediate of size byte, word, doubleword or quadword, followed by a register of the same size
C6 0 ibwl r     # opcode 0xC6, extension 0, accepts an unsigned immediate of size byte, word or doubleword, followed by a register of the same size

Example for "add" instruction (this can be extended to all other arithmetic instructions, like adc, sub, xor, and, etc.):
04 z ibw R_0
83 0 Ib rwlq
05 z Il R_0l
80 0 ibwl r
05 z Il R_0q
81 0 Il rq
00 r Rbwlq r
02 r rbwlq R

sal:
D0 4 I_1 rbwlq
D2 4 R_1b rbwlq
C0 4 Ib rbwlq

fadd:
D8 0 ml
DC 0 mQ
D8C0 o f f_0
DCC0 o f_0 f

lods:
AC z -bwlq

nop:
90 z
0F1F 0 rwl

adcx:
66)0F38F6 r rlq R

adox:
F3)0F38F6 r rlq R

bndcu:
F2)0F1A r rQ R

bndcn:
F2)0F1B r rQ R

bndcl:
F3)0F1A r rQ R

bndmk:
F3)0F1B r mQ R

bndmov:
66)0F1A r rQ R
66)0F1B r RQ r

bsf:
0FBC r rwlq R

bsr:
0FBD r rwlq R

bswap:
0FC8 o Rlq

bt:
0FA3 r Rwlq r
0FBA 4 Ib rwlq

enter:
C8 z iw ib

cvttpd2pi:
66)0F2C r x N





Extensions:
    - 0-7 - opcode extension, goes to modrm
    - 'r' - register id goes to modrm
    - 'o' - register id goes to opcode (no modrm)
    - 'z' - solitary opcode (no modrm, might be followed by an immediate/offset though)

Operand names:
    For the following operand types, the capitalization specifies whether a memory operand can
    be used instead (uppercase meaning memory can't be used, lowercase meaning memory can be used):
    - 'r' - GPR register
    - 'n' - MMX register
    - 'x' - XMM register
    - 'y' - YMM register
    - 'z' - ZMM register

    For the following operand type, the capitalization specifies whether the operand is signed
    or unsigned (this mostly matters for size inference):
    - 'i' - immediate

    For the following operand types, capitalization doesn't matter (but lowercase is preferred):
    - 'm' - memory only
    - 's' - segment register
    - 'f' - floating-point register (st)
    - 'b' - bound register (bnd)
    - 'k' - mask register

    Implicit types (these won't be encoded in the instruction):
    - Follow operand name with '_', then specification.
        For registers, this is the register id (e.g. ax = R_0)
        For immediates, this is the immediate value (e.g. 1 = i_1)
    - '-' - invisible operand (this is for mnemonics that have a size but no operands, e.g. string operations or pushf)

Operand sizes (capitalize if prefix isn't needed and memory ops should default to this):
    - 'b' - byte
    - 'w' - word
    - 'l' - double-word
    - 'q' - quad-word
    - 'o' - quad-word, but recognized to other operands as sign-extended double-word
    - '~' - before a size that must be explicitly chosen by an opcode suffix